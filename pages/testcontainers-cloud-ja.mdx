---
title: Testcontainers Cloud ドキュメント
description: Testcontainers Cloudを使用してTestcontainersのテストを実行すると、すぐに利用できます。人気のある技術を使用してアプリケーションをテストするための同じTestcontainersモジュールにアクセスでき、ローカルマシンで重いコンテナを起動する必要がありません。
---

import Image from 'next/image'
import { Callout } from 'nextra/components'

# Testcontainers Cloud ドキュメント

## 概要

Testcontainers Cloud を使用して Testcontainers のテストを実行すると、すぐに利用できます。人気のある技術を使用してアプリケーションをテストするための同じ Testcontainers モジュールにアクセスでき、ローカルマシンで重いコンテナを起動する必要がありません。

## Testcontainers Cloud はどのように動作するのか？

Testcontainers Cloud エージェントは SSH トンネルを開き、クラウド環境内の Docker デーモンに接続します。

Testcontainers Cloud を使用することで、ローカル環境でコンテナを実行する必要がなくなります。ローカル環境でテストを実行すると、Testcontainers Cloud エージェントが SSH トンネルを開き、クラウド環境内の Docker デーモンに接続します。この際、Testcontainers を使用したテストで定義された Docker イメージをクラウド環境で取得し、コンテナを起動します。クラウド環境への接続はテスト実行中のみアクティブであり、テストスイートの完了後、Testcontainers Cloud は短時間待機した後、自動的に接続を閉じ、割り当てられたリソースを削除します。

![Testcontainers Desktopのクラウド接続図](/testcontainers-cloud-ja/tcd_cloud_diagram.png)

## はじめる

### クライアントをインストール

1. Testcontainers Desktopをダウンロードしてインストールします
2. `Run with Testcontainers Cloud` を選択します

<br />

<div align="center">
  <Image src="/testcontainers-cloud-ja/tcd-cloud-runtime.png" alt="Testcontainers Desktop のクラウドランタイム" width={400} height={1000}/>
</div>

Testcontainers Cloud 上で実行されるコンテナを使用して、Testcontainers ベースのテストを実行できるようになりました。

もし Testcontainers を使用した既存のテストがない場合は、Testcontainers Cloud があなたの環境で正しく設定されていることを確認するためのいくつかのテストを含むサンプルプロジェクトを利用することができます。

### サンプルプロジェクト

#### .NET

```shell
git clone https://github.com/AtomicJar/testcontainers-cloud-dotnet-example
cd testcontainers-cloud-dotnet-example
dotnet test --logger:"console;verbosity=detailed"
```

#### Go

```shell
git clone https://github.com/AtomicJar/testcontainers-cloud-go-example
cd testcontainers-cloud-go-example
go mod download
go test -v -count=1
```

#### Java

```shell
git clone https://github.com/AtomicJar/testcontainers-cloud-java-example
cd testcontainers-cloud-java-example
./mvnw test
```

#### Node.js

```shell
git clone https://github.com/AtomicJar/testcontainers-cloud-nodejs-example
cd testcontainers-cloud-nodejs-example
npm install
npm test
```

### 既存のテストの実行

Testcontainers ベースの統合テストは、Testcontainers Cloud を使用することでそのまま実行できます。Testcontainers Cloud の使用感をより良く理解するために、短時間で2回連続してテストを実行することをおすすめします。これにより、ウォームアップされた環境での動作を体験できます。

Testcontainers Cloud は、IDE からテストを実行する場合にも動作します。そのため、最初に IDE からいくつかのテストを実行して、プロジェクトのテストが Testcontainers Cloud でどのように動作するかを確認するのが便利です。通常の IDE の機能を使用してテストを実行し、Testcontainers Cloud が使用されている Docker 実装であることを確認するために出力ログをチェックしてください。

ローカルの Docker に切り替えたい場合は、Testcontainers Cloud クライアントアプリを停止するだけで、Testcontainers ベースの統合テストがローカル Docker を使用して実行されるようになります。

### 適切なコンテナランタイムの選択方法

システムが Docker daemon と Testcontainers Cloud の両方にアクセスできる場合、Testcontainers ライブラリは次の順序で使用する Docker 環境を決定します:

1. `~/.testcontainers.properties` ファイルを確認（存在する場合）:
    - `tc.host` プロパティからDockerデーモンの場所を取得。

2. 環境変数 `DOCKER_HOST` から Docker daemon の場所を取得。
3. 現在のオペレーティングシステムのデフォルトの Docker ロケーションを試す。

Testcontainers Cloud エージェント（Desktop と CI の両方）は、`~/.testcontainers.properties` ファイルに自分のロケーションを設定します。これにより、テストは自動的に Testcontainers Cloud を優先します。

### 特定のプロジェクトで無効化

Testcontainers Cloudを起動すると、デフォルトでローカル環境がTestcontainersのテストで使用されるように構成されます。ただし、特定のプロジェクトではこれを無効化したい場合があります。例えば、古いTestcontainersライブラリを使用しており、Testcontainers Cloudと互換性がない場合や、クラウドベースのコンテナ実行に適していないコードパターンを使用している場合です。

特定のプロジェクトでグローバルな Testcontainers Cloud 設定を使用しないようにするには、プロジェクト内（クラスパス上）の `testcontainers.properties` 設定ファイルで `dockerconfig.source` プロパティを更新します。

このオプションは Java 用 Testcontainers でのみ利用可能です。

以下の内容を含む `testcontainers.properties` 設定ファイルをプロジェクトのクラスパスに追加してください：

```properties
dockerconfig.source=autoIgnoringUserProperties
```

Testcontainers Cloud クライアントアプリを実行したままにしても問題ありませんが、それ以上の変更は必要ありません。このプロジェクトは、通常の自動 Testcontainers 環境検出メカニズムを使用して、Docker と通信するための適切な方法を見つけるようになります。

### Turbo モードでテストを並列化

Testcontainers Cloud の Turbo モードを使用すると、テストを並列実行できるようになります。各テストプロセスが独自のクラウド環境を受け取るため、テストの並列化がスケーラブルになります。テストを並列化することは、ビルドの実行速度を向上させる方法の1つです。

テストスイートの構成や利用可能なコンピューティングリソースによっては、ローカルリソースのボトルネックにより並列テストがパフォーマンス向上に繋がらない場合もあります。Testcontainers Cloud の Turbo モードでは、Testcontainers テストを実行する各プロセスに1つのクラウド環境が割り当てられるため、この問題を解決します。

これにより、同時にテストを実行するプロセス数を増やしても、ローカルコンピュートリソースの負荷が直線的に増加することはありません。クラウド環境のスケーラビリティによって、テストの実行速度を向上させることができます。

Turboモードは、大規模なテストスイートが許容範囲を超えて長時間実行される課題を抱えるユーザーにとって特に有益です。以下に、Testcontainers Cloud の Turbo モードを有効化してテストを並列実行する方法を説明します。

<Callout type="info">
  Turboモードは現在、Free アカウントでは制限されています。
</Callout>

#### デスクトップで Testcontainers Cloud の Turbo モードを開始する

Testcontainers Desktop アプリケーションで、Turbo モードを有効化するには、Turbo モードのチェックボックスを選択してください。

<br />

<div align="center">
  <Image src="/testcontainers-cloud-ja/tcd-turbo-mode.png" alt="Testcontainers Cloud の Turbo モード" width={400} height={1000}/>
</div>

#### CI で Turbo モードを有効化する方法

CI でエージェントを起動する際、`--max-concurrency=N` フラグを指定すると、このエージェントを使用するプロセスが利用できる最大 N 個の並列 Testcontainers Cloud 環境を有効化できます。

- `--max-concurrency` のデフォルト値は4です。
- 環境変数 `TC_CLOUD_CONCURRENCY` を使用して並列実行オプションを設定することもできます。例えば、以下のように設定します:

```bash
export TC_CLOUD_CONCURRENCY=2
```

これで、Testcontainers Cloud のスケーラビリティを利用して並列テストを実行する準備が整いました。並列テストを初めて行う場合、以下の一般的なビルドツールでの試し方をご覧ください。

#### Gradleを使用したJavaプロジェクトでのTurboモード有効化

Gradle でテストを並列実行するには、`build.gradle` ファイルのテストタスクに `maxParallelForks` を追加します：

```groovy
test.maxParallelForks = 4
```

これにより、Gradleは最大4つのプロセスを使用してテストを実行します。Turboモードが設定されている場合、各プロセスで作成されたコンテナは同じDocker環境をオーバーロードしません。

JavaプロジェクトでTurboモードを試してみたい場合は、GitHubリポジトリの手順に従ってサンプルプロジェクトを使用してみてください。

#### Mavenを使用したJavaプロジェクトでのTurboモード有効化

Maven をビルドツールとして使用している場合、テスト実行には Surefire プラグインを使用している可能性があります。Surefire プラグインは並列テスト実行をサポートしており、その有効化方法は公式ドキュメントを参照できます。

一般的に、Maven で並列テストを実行するには、`pom.xml` ファイルの Surefire または Failsafe プラグインの設定に `parallel` および `forkCount` プロパティを追加します。以下は、最新バージョンの Surefire プラグインのサンプル設定です：

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-surefire-plugin</artifactId>
  <version>3.0.0-M7</version>
  <configuration>
    <parallel>classes</parallel>
    <forkCount>4</forkCount>
  </configuration>
</plugin>
```

Java プロジェクトで Turbo モードを試したい場合は、GitHub リポジトリの手順に従ってサンプルプロジェクトを使用してみてください。

#### Turboモードが有効化されたかを確認する方法

Testcontainers Cloud で Turbo モードを有効化し、ビルドツールで並列テストを設定した場合、テストを実行すると Testcontainers Cloud アプリケーションの「connection」タブで複数のリース割り当てが表示されるはずです。

![Testcontainers DesktopでTurboモードが有効になっているか確認する](/testcontainers-cloud-ja/tcd-turbo-mode-connected.png)

#### Testcontainers Cloud がどのコンテナを同じクラウド環境で実行するかを決定する方法

Testcontainers Cloud ではセッションを使用してコンテナを区別します。同じプロセスであれば、例えば複数のコンテナを起動する必要がある場合でも、同じクラウド環境に接続します。

一方で、並列プロセスが実行される場合、現在実行中の Testcontainers Cloud エージェントの最大並列設定が許容する限り、新しいクラウド環境が割り当てられます。

したがって、Turbo モードを設定している場合でも、テストプロセスが1つしかない場合は、すべてのコンテナが同じクラウド環境で実行されます。たとえその1つのプロセス内でテストを並列実行していたとしても同様です。

複数のテストプロセス（例えばフォークされたJVM）を使用している場合、Turbo モードが有効になっていれば、可能な限り各JVMに専用のクラウド環境が割り当てられます。

### メモリ制限

各Testcontainers Cloudセッションには8GBのRAMが割り当てられます。この情報は接続が確立された際のログで確認できます:

```shell
Connected to docker: 
  Server Version: 70+testcontainerscloud
  API Version: 1.41
  Operating System: Ubuntu 22.04 LTS
  Total Memory: 7396 MB
```

現在、1つのTestcontainers Cloudセッションのメモリ使用量を拡張または制限することはできません。

### テストがクラウドで実行されているか確認する方法

Testcontainers Desktop アプリケーションの「Connection」セクションを確認します。

ローカルマシンに Testcontainers Cloud アプリケーションをインストールしている場合、トレイメニューにアプリアイコンが表示されます。テストが Testcontainers Cloud アプリケーションを使用して実行されていることを確認するには、Testcontainers Cloud アプリケーションのアイコンをクリックしてください。接続状態として「Running」または「Passive」が表示されます。「Connection」サブメニューをクリックすると、詳細な接続情報が確認できます。

- **Connected to**: 接続されているゾーン/リージョン（接続遅延がミリ秒単位で表示されます）

- **Leases**: 開かれたコネクションのID（状態）

`ACTIVE` Leases: コネクションがアクティブで、テストのための Testcontainers Cloud リソースが割り当てられている状態

`PASSIVE` Leases: コネクションが閉じられ、Testcontainers Cloud リソースが割り当てられていない状態

- **Data**: R: 読み取りデータ量（kB）, W: 書き込みデータ量（kB）

#### 実行中の状態（Running State）

![Testcontainers Desktop cloud connection status - active](/testcontainers-cloud-ja/tcd-cloud-connection-active.png)

#### パッシブ状態 (Passive State)

![Testcontainers Desktop cloud connection status - passive](/testcontainers-cloud-ja/tcd-cloud-connection-passive.png)

### システム再起動時にクライアントを自動起動

ユーザー体験を向上させるため、デスクトップアプリケーションのメニューに「Autostart」チェックボックスを追加しました。コンピュータを起動または再起動した際に Testcontainers Cloud を自動的に起動したい場合は、このチェックボックスを有効にしてください。この機能は、サポートされているすべてのオペレーティングシステムで同じように動作します。

<br />

<div align="center">
  <Image src="/testcontainers-cloud-ja/tcd-autostart.png" alt="Testcontainers Desktop autostart" width={400} height={1000}/>
</div>

## テストセッションにプロジェクトタグを付ける

Testcontainers Cloud を使用してテストを実行する際、[project](https://newsletter.testcontainers.com/announcements/tag-your-test-sessions-by-project) または [workflow](https://newsletter.testcontainers.com/announcements/link-your-test-sessions-to-your-ci-pipeline) の名前や URL を指定できます。この情報は Testcontainers Cloud のダッシュボードに表示され、実行中のテストやワークフローを簡単に特定することができます。

<br />

<div align="center">
  <Image src="/testcontainers-cloud-ja/tcc-project-and-workflow.png" alt="Testcontainers Desktop project and workflow" width={400} height={1000}/>
</div>

URL は任意で、指定を省略することも可能です。GitHub Actions を使用している場合、ワークフロー名と URL は自動的に検出され、Testcontainers Cloud ダッシュボードに表示されます。

### CIで環境変数を使用して設定

以下の環境変数を設定してください：

- プロジェクトの場合
    - `TCC_PROJECT_KEY` / `TCC_PROJECT_URL`
    - または、`~/.testcontainers.properties` ファイルで `tcc.project.key` と `tcc.project.url` プロパティを設定できます。
- ワークフローの場合
    - `TCC_WORKFLOW_KEY` / `TCC_WORKFLOW_URL`
    - または、`~/.testcontainers.properties` ファイルで `tcc.workflow.key` と `tcc.workflow.url` プロパティを設定できます。

### Testcontainers tests 内のラベルを使用して設定

- プロジェクト用
    - `cloud.testcontainers.tcc.project.key` / `cloud.testcontainers.tcc.project.url`
- ワークフロー用
    - `cloud.testcontainers.tcc.workflow.key` / `cloud.testcontainers.tcc.workflow.url`

## 使用の最適化

チームが Testcontainers Cloud の利用を拡大するにつれて、使用効率を最適化したいと思う場合があるでしょう。このセクションでは、いくつかの役立つテクニックを紹介します。

### Turboモードを調整する

[Turbo モード](#turbo-モードでテストを並列化)を使用すると、複数のワーカーを要求してテストを並列実行できます。一般的に、これはCIパイプラインの実行時間を短縮し、全体的な使用量を一定に保つための有効な方法です。例えば、以前は単一のワーカーで15分かかっていたパイプラインが、3つのワーカーで並列化されると5分で完了する場合があります。

しかし、必要以上のワーカーを要求すると、実行時間の大幅な短縮が得られないにもかかわらず、全体の使用量が増加する可能性があります。このような場合、要求するワーカー数（例: `--max-concurrency` フラグ）を減らし、実行時間が一定に保たれることを確認することで、非効率な使用を取り戻すことができます。

### テスト完了時にワーカーを瞬時に終了する

デフォルトでは、ワーカーは一定期間アクティブな状態を維持してからシャットダウンします。これは特にデスクトップ環境でスムーズなユーザー体験を提供するためです。しかし、CIパイプラインでは、特定のパイプラインやジョブが完了した後に、Testcontainers Cloud ワーカーへのアクセスが不要になることが予測できる場合があります。このような場合、エージェントのシャットダウン時にワーカーを瞬時に終了することで使用を最適化できます。

これを行うには、エージェントを起動する際に `--terminate` フラグを引数として渡すだけです。あるいは、エージェントがまだ実行中の場合に `terminate` コマンドを呼び出すことでも実現できます。

## Dockerとの互換性

### Docker CLIの使用

現在、Dockerコンテキストを使用して、基盤となる Docker API に直接アクセスすることが可能です:

```shell
docker context use tcc
docker ps
```

また、TCCセッションのCPUやメモリ使用量に関する情報を確認するには、以下のコマンドを使用します:

```shell
docker stats
```

または

```shell
DOCKER_CONTEXT=tcc docker stats
```

ただし、Testcontainers Cloudは汎用的な「Docker-as-a-Service」ではなく、これらの機能は実装上の詳細として扱うべきである点に注意してください。

### ローカルファイルシステムのマウント

ローカルファイルシステムからコンテナへのファイルのマウントは現在実装されていません。その代わりに、`copyFileToContainer` および `copyFileFromContainer` メソッドの使用を検討してください。

例えば、コンテナを定義する際にファイルをコピーする場合：

```java
GenericContainer myContainer = new GenericContainer(ALPINE_IMAGE)
    .withCopyFileToContainer(
        MountableFile.forClasspathResource("/mappable-resource/"),
        directoryInContainer
    );
```

また、コンテナからファイルをコピーする場合は以下のようにします：

```java
myContainer.copyFileFromContainer(directoryInContainer + fileName, destinationOnHost);
```

ファイル操作に関する詳細な例は、[ライブラリのドキュメント](https://testcontainers.com/guides/)に記載されていますので参照してください。

## ネットワーク設定

### インターナル Docker レジストリの使用

Testcontainers Cloud は、パブリックインターネットからアクセスできない「プライベート」レジストリからイメージを取得する必要があるユーザー向けに設定を提供します。Docker Hub、Amazon ECR、GCR などのレジストリを使用している場合、この機能は不要です。これらのレジストリはパブリックインターネットに公開されています。

#### Testcontainers Desktop での設定方法

ユーザーごとの設定を `~/.testcontainers.properties` ファイルに追加

```properties
cloud.private_registry.proxy.url = https://private.registry.example.com:8999
```

複数のレジストリを設定することも可能です：

```properties
cloud.private_registry.proxy.url = https://private.registry.example.com:8999
cloud.private_registry.proxy.url.second = https://private2.registry.example.com:8999
cloud.private_registry.proxy.url.test = https://test.registry.example.com:8999
```

<Callout type="info">
  `.url.` の後の部分はユニークである必要がありますが、任意の値を使用できます（利便性のための識別子に過ぎません）。
</Callout>

特定のイメージ（例: `private.registry.example.com:8999/prefix/name`）を取得可能にするには、次の設定を行います：

すべてのイメージを許可する場合：

```properties
cloud.private_registry.proxy.allowed_image_name_globs = **
```

より具体的に特定のイメージを許可する場合：

```properties
cloud.private_registry.proxy.allowed_image_name_globs = prefix/*,prefix/name
```

このように、取得を許可するイメージをカンマ区切りで指定します。このリストを （すべて許可）ではなく、可能な限り小さく保つ ことを推奨します。

証明書関連の問題を無視する場合、以下の設定を使用します：

```properties
cloud.private_registry.proxy.insecure_skip_verify = true
```

ただし、この設定は推奨されません。この設定を有効にすると、中間者攻撃（MitM攻撃） のリスクが生じるため、接続問題をテストする場合など、限られた状況でのみ使用してください。

これらの設定変更は、Testcontainers Cloudアプリケーションの起動時に読み込まれるため、設定を反映させるには**アプリケーションを再起動**する必要があります。

#### エージェントCLIの使用方法

CLIを使用してプライベートレジストリを設定する場合、以下のようにフラグを追加します（有効にしたい各レジストリごとに指定可能です）:

```shell
--private-registry-url=https://private.registry.example.com:8999 --private-registry-url=https://private2.registry.example.com:8999
```

以下のようなイメージを取得可能にします：

- `private.registry.example.com:8999/prefix/name`
- `private.registry.example.com:8999/name`

すべてのイメージを許可する場合：

```shell
--private-registry-allowed-image-name-globs=**
```

より具体的に特定のイメージを許可する場合

```shell
--private-registry-allowed-image-name-globs=prefix/*,prefix/name
```

このように、取得を許可するイメージをカンマ区切りで指定します。すべてを許可するよりも、許可リストを可能な限り小さく保つことを推奨します。

#### 現在の制限事項

- イメージの取得のみサポート、イメージのプッシュ操作は許可されていません。
- プロキシ設定は各マシンで設定する必要がありますが、将来的には組織全体で設定可能になる予定です。
- パブリックおよびプライベートDockerレジストリの資格情報やトークンは、Testcontainers ライブラリおよび Testcontainers Cloud で可視化されます（データはプロキシされますが、保存はされません）。
- 取得したイメージは、ユーザーの Testcontainers Cloud VM 内にキャッシュされます。このキャッシュは、約30分間非アクティブになると自動的に削除されます。

<Callout type="info">
  エージェントでは、セキュリティ対策として、プロキシ接続が設定された単一のレジストリホストに対してのみ許可されています。また、HTTPメソッドはHEADおよびGETに制限されており、リクエストが許可されるのは、あらかじめ設定された許可リストに一致するパスだけです。この許可リストは、エージェントで許可されたイメージに基づいています。

  現在、この設定はインストール単位で構成されていますが、将来的には中央で一括管理できるようになる見込みです。
</Callout>

### プロキシ環境での使用方法

Testcontainers Cloud クライアントをプロキシに向けるには、環境変数または Testcontainers の設定を使用して構成できます。HTTP プロキシを使用しているネットワークで Testcontainers Cloud クライアントを実行する場合、以下の3つの方法で設定が可能です。

#### 1. 環境変数を使用する場合

以下の環境変数のいずれかがプロキシを指すように設定されたシェルからクライアントを起動することで、クライアントは自動的にそれらを認識し、設定が完了します：

```
http_proxy または HTTP_PROXY
https_proxy または HTTPS_PROXY
no_proxy または NO_PROXY
```

#### 2. Testcontainers Cloud プロパティファイルを使用する場合

シェルの環境変数を設定できない場合、次のオプション行を追加してプロキシ設定を行うことができます：

```properties
http_proxy=host:port
https_proxy=host:port
no_proxy=host1, host2
```

これを以下のいずれかの場所に保存されている `cloud.properties` ファイルに記述してください：

##### MacOS および Linux

`$XDG_CONFIG_HOME` が設定されている場合：

```shell
$XDG_CONFIG_HOME/testcontainers/cloud.properties
```

設定されていない場合：

```shell
$HOME/.config/testcontainers/cloud.properties
```

##### Windows

`$XDG_CONFIG_HOME` が設定されている場合：

```cmd
%xdg_config_home%\testcontainers\cloud.properties
```

設定されていない場合：

```cmd
%userprofile%\.config\testcontainers\cloud.properties
```

#### 3. Testcontainers設定を使用する場合

もう1つの方法として、設定を $HOME/.testcontainers.properties ファイルに記述してプロキシ設定を行うこともできます。使用するキーの名前は、前述の Testcontainers Cloud プロパティファイルと同じです

## トラブルシューティング

### ログへのアクセス

#### Testcontainers Desktop

アプリケーションはログをシステム依存の場所に保存します。ログへの最も簡単なアクセス方法は、メニューの `Preferences > Show logs...` からです。

ログファイルの保存先を手動で確認する場合は以下の場所を参照してください：

- macOS: `$HOME/Library/Logs/AtomicJar/testcontainers.cloud.desktop/testcontainers-cloud-desktop.log`
- Linux: `${XDG_CACHE_HOME:-$HOME}/.cache/AtomicJar/testcontainers.cloud.desktop/testcontainers-cloud-desktop.log`
- Windows: `%LocalAppData%/AtomicJar/testcontainers.cloud.desktop/testcontainers-cloud-desktop.log`

<Callout type="info">
  ログファイルは5MBを超えるとローテーションされます。
</Callout>

#### Testcontainers Cloud エージェント

エージェントは実行時に `stderr` にログを書き込みます。ログをファイルに保存するには以下のようにエージェントを起動します:

```shell
./tcc-agent > "./tcc/agent.log" 2>&1 &
```

これにより、stdout と stderr の両方が指定したファイルにリダイレクトされます。

#### GitHub Action

公式の [GitHub Action](https://github.com/AtomicJar/testcontainers-cloud-setup-action) では `logfile` パラメータを使用して特定のログファイルへの書き込みをサポートしています。その後、[actions/upload-artifact](https://github.com/actions/upload-artifact)アクションを使用してログファイルをアップロードできます。

### 詳細ログの有効化

詳細ログは、追加のデバッグ情報を取得する際に役立ちます。

#### Testcontainers Desktopでの設定

`~/.testcontainers.properties` ファイルに次のプロパティを追加してください：

```
cloud.logs.verbose = true
```

設定を反映するには、クライアントを終了し、再起動する必要があります。

#### エージェントCLIでの設定

CLI呼び出しに以下のフラグを追加します:

```shell
--verbose
```

または、環境変数を設定します:

```shell
export TC_CLOUD_LOGS_VERBOSE=true
```

エージェントCLIは、Testcontainers Desktop の設定セクションで指定されたプロパティ値も尊重します。

#### また、Linuxでは次の方法を試すことができます

`~/.profile` ファイルに以下の行を追加します：

```shell
export TC_CLOUD_LOGS_VERBOSE=true
```

#### MacOSでのデバッグ

環境変数を利用してデスクトップクライアントをターミナルから起動できます：

```shell
open -W --stdout $(tty) --stderr $(tty) /Applications/Testcontainers\ Desktop.app
```

すべての環境変数をインラインで設定することも可能です：

```shell
TC_CLOUD_LOGS_VERBOSE=true open -W --stdout $(tty) --stderr $(tty)
/Applications/Testcontainers\ Desktop.app
```

#### 有効化の確認方法

設定が正しく有効化されていれば、ログの初期段階で次のような行が表示されます:

```shell
2022-11-07T18:47:56.964Z --- DBG Verbose output enabled
```

### Dockerアクティビティが検出されない場合

#### 主な原因

「this worker was requested by the Testcontainers Cloud agent but seemingly didn't run any containers.」という警告メッセージが表示されることがあります。この警告は、ワーカーが想定された作業を行わなかったことを示します。この問題は以下の状況で発生する可能性があります：

1. **ターミナルで直接Dockerコマンドを実行した** 通常、Testcontainers Cloud のユーザーは、コンテナのライフサイクルを管理するために Testcontainers オープンソースライブラリを使用します。TCC Docker コンテキストに対して生の Docker コマンドを直接実行することはサポートされていません。例えば、Testcontainers Cloud エージェントがアクティブだが接続中のワーカーがいない状態で、`docker ps` のような Docker コマンドを直接実行すると、新しいワーカーが意図せず起動してしまう可能性があります。

2. **CI パイプラインで Testcontainers Cloudエージェントを起動したが、Testcontainers ベースのテストが含まれていない** CI/CDパイプライン内で Testcontainers Cloud エージェントを起動する場合、パイプラインジョブに Testcontainers ベースのテストが含まれていることを確認する必要があります。テストが含まれていない場合、ワーカーは待機状態のままとなり、実際には何も作業を行いません。

#### トラブルシューティング手順

「No activity detected」の警告が表示された場合は、以下の手順を試してください:

1. CI パイプラインの設定を確認: CI/CDパイプラインの設定を確認し、Testcontainers ベースのテストが実行される適切なステージが構成されていることを確認してください。パイプラインがこれらのテストを実行するようトリガーを設定します。

2. Docker コマンドの干渉を回避: Testcontainers Cloud エージェントがアクティブな状態で、デスクトップマシン上で直接 Docker コマンドを実行しないようにしてください。これらの外部コマンドは、エージェントがコンテナを制御および管理する能力に干渉する可能性があります。

3. Testcontainers の統合を確認: テストコードベースに Testcontainers が正しく統合されていることを再確認してください。必要な依存関係と設定が正しく構成されていることを確認し、テストが Testcontainers API を使用してコンテナの作成と管理を適切に呼び出していることを確認します。

#### 結論

Testcontainers Cloud で表示される「No activity detected」の警告は、ワーカーが期待どおりにコンテナを実行しなかったことを示します。デスクトップでの外部 Docker コマンドの実行を避け、CI パイプラインが Testcontainers ベースのテストを実行するよう設定することで、「空の」ワーカーを最小限に抑え、Testcontainers Cloud の機能を最大限に活用できます。

問題が解決しない場合は、Testcontainers Cloud のドキュメントを参照するか、サポートに問い合わせてさらに問題を解決してください。

